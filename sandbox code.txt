// Code from http://phaser.io/sandbox/edit/FhJLhNZm

// Preload
function preload() {
  game.load.baseURL = 'https://raw.githubusercontent.com/TepigMC/Voltorb-Flip/master/';
  game.load.crossOrigin = 'anonymous';

  game.load.image('background', 'sprites/background.png');
  game.load.spritesheet('cards', 'sprites/cards.png', 24, 24);
  game.load.spritesheet('memos', 'sprites/memos.png', 24, 24);
  game.load.spritesheet('selection', 'sprites/selection.png', 28, 28);

  game.load.bitmapFont('board_numbers', 'fonts/board_numbers.png', 'fonts/board_numbers.fnt');

  game.stage.smoothed = false;
}

// Create
var settings = {
  boardSize: 5,
  cardSize: 24,
  cardMargin: 8
};
var board;
var keys = {};

function create() {
  var background = game.add.sprite(0, 0, 'background');
  var cards = generateCards(3);
  var selection = new Selection(0, 0);
  board = new Board(background, cards, selection);

  addKey('UP', function() { board.selection.moveUp(); }, this);
  addKey('DOWN', function() { board.selection.moveDown(); }, this);
  addKey('LEFT', function() { board.selection.moveLeft(); }, this);
  addKey('RIGHT', function() { board.selection.moveRight(); }, this);
  addKey('SPACEBAR', function() { board.selectedCard().flip(); }, this);
  addKey('A', function() { board.selectedCard().toggleMemo(0); }, this);
  addKey('S', function() { board.selectedCard().toggleMemo(1); }, this);
  addKey('Z', function() { board.selectedCard().toggleMemo(2); }, this);
  addKey('X', function() { board.selectedCard().toggleMemo(3); }, this);

  getRandomBoard();
}

function generateCards(value) {
  var cards = [];
  for (var i = 0; i < settings.boardSize; i++) {
    var row = [];
    for (var j = 0; j < settings.boardSize; j++) {
      row.push(new Card(i, j, value));
    }
    cards.push(row);
  }
  return cards;
}

function getRandomBoard(level) {
  var xmlhttp;
  if (window.XMLHttpRequest) {
    xmlhttp = new XMLHttpRequest();
  }
  else {
    xmlhttp=new ActiveXObject('Microsoft.XMLHTTP');
  }
  xmlhttp.onreadystatechange = function() {
    if (xmlhttp.readyState == 4 && xmlhttp.status == 200) {
      console.log(xmlhttp.responseText);
    }
  }

  xmlhttp.open('POST', 'http://www.voltorbflip.com/cgi-bin/vflip-ajax.cgi', true);
  xmlhttp.setRequestHeader('Content-type', 'application/x-www-form-urlencoded');
  xmlhttp.send('command=CREATE&size=' + settings.boardSize + '&level=' + level);
}

function addKey(keyName, callback, listenerContext) {
  var key = game.input.keyboard.addKey(Phaser.Keyboard[keyName]);
  key.onDown.add(callback, listenerContext);
  keys[keyName] = key;
}

function cardPos(pos) {
  return settings.cardMargin + pos * (settings.cardSize + settings.cardMargin);
}

var Board = (function () {
  function Board(background, cards, selection) {
    this.background = background;
    this.setCards(cards);
    this.selection = selection;
  }

  Board.prototype.setCards = setCards;
  Board.prototype.calculateTotals = calculateTotals;
  Board.prototype.selectedCard = selectedCard;

  function setCards(cards) {
    this.cards = cards;
    this.calculateTotals();
  }

  function calculateTotals() {
    var rows = [];
    var cols = [];
    for (var i = 0; i < settings.gridSize; i++) {
      var row = {coins: 0, voltorbs: 0, coinText: null, voltorbText: null};
      var col = {coins: 0, voltorbs: 0, coinText: null, voltorbText: null};
      for (var j = 0; j < settings.gridSize; j++) {
        row.coins += this.cards[i][j].value;
        col.coins += this.cards[j][i].value;
        if (this.cards[i][j].value === 0) {
          row.voltorbs++;
        }
        if (this.cards[j][i].value === 0) {
          col.voltorbs++;
        }
      }
      row.coinText = game.add.bitmapText(177, cardPos(i), 'board_numbers', ('00' + col.coins).slice(-2), 32);
      row.voltorbText = game.add.bitmapText(185, cardPos(i) + 13, 'board_numbers', col.voltorbs.toString(), 32);
      col.coinText = game.add.bitmapText(cardPos(i) + 9, 168, 'board_numbers', ('00' + col.coins).slice(-2), 32);
      col.voltorbText = game.add.bitmapText(cardPos(i) + 17, 181, 'board_numbers', col.voltorbs.toString(), 32);
      //rows.push(row);
      //cols.push(col);
      rows.push(new RowColData(row.coins, row.voltorbs, 6, i));
      cols.push(new RowColData(col.coins, col.voltorbs, i, 6));
    }
    this.rows = rows;
    this.cols = cols;
  }

  function selectedCard() {
    return this.cards[this.selection.r][this.selection.c];
  }

  return Board;
})();

var RowColData = (function () {
  function RowColData(coins, voltorbs, i, j) {
    this.coinText = game.add.bitmapText(tilePos(i) + 9, tilePos(j), 'board_numbers', '00', 32);
    this.voltorbText = game.add.bitmapText(tilePos(i) + 17, tilePos(j) + 13, 'board_numbers', '00', 32);
    this.setCoins(coins);
    this.setVoltorbs(voltorbs);
  }

  RowColData.prototype.setCoins = setCoins;
  RowColData.prototype.setVoltorbs = setVoltorbs;

  function setCoins(coins) {
    this.coins = coins;
    this.coinText.setText(('00' + coins).slice(-2));
  }

  function setVoltorbs(voltorbs) {
    this.voltorbs = voltorbs;
    this.voltorbText.setText(('00' + voltorbs).slice(-2));
  }

  return RowColData;
})();

var Card = (function () {
  function Card(r, c, value) {
    this.sprite = initSprite(r, c);
    this.memos = initMemos(r, c);
    this.r = r;
    this.c = c;
    this.value = value;
  }

  Card.prototype.flip = flip;
  Card.prototype.toggleMemo = toggleMemo;

  function flip() {
    this.sprite.frame = this.value + 1;
    this.memos.visible = false;
  }

  function toggleMemo(memo) {
    this.memos.getChildAt(memo).visible = !this.memos.getChildAt(memo).visible;
  }

  function initSprite(r, c) {
    var sprite = game.add.sprite(cardPos(c), cardPos(r), 'cards', 0);
    sprite.inputEnabled = true;
    sprite.events.onInputDown.add(onClick, this);
    return sprite;
  }

  function initMemos(r, c) {
    var memos = game.add.group();
    var memo0 = new Phaser.Sprite(game, cardPos(c), cardPos(r), 'memos', 0);
    var memo1 = new Phaser.Sprite(game, cardPos(c), cardPos(r), 'memos', 1);
    var memo2 = new Phaser.Sprite(game, cardPos(c), cardPos(r), 'memos', 2);
    var memo3 = new Phaser.Sprite(game, cardPos(c), cardPos(r), 'memos', 3);
    memo0.visible = false;
    memo1.visible = false;
    memo2.visible = false;
    memo3.visible = false;
    memos.add(memo0);
    memos.add(memo1);
    memos.add(memo2);
    memos.add(memo3);
    return memos;
  }

  function onClick() {
    this.flip();
    board.selection.move(this.r, this.c);
  }

  return Card;
})();

var Selection = (function () {
  function Selection(r, c) {
    this.sprite = game.add.sprite(0, 0, 'selection', 0);
    this.move(r, c);
  }

  Selection.prototype.move = move;
  Selection.prototype.moveRelative = moveRelative;
  Selection.prototype.moveUp = moveUp;
  Selection.prototype.moveDown = moveDown;
  Selection.prototype.moveLeft = moveLeft;
  Selection.prototype.moveRight = moveRight;

  function move(r, c) {
    r = (r < 0 ? 0 : (r >= settings.gridSize ? settings.gridSize - 1 : r));
    c = (c < 0 ? 0 : (c >= settings.gridSize ? settings.gridSize - 1 : c));
    this.r = r;
    this.c = c;
    this.sprite.x = cardPos(c) - 2;
    this.sprite.y = cardPos(r) - 2;
  }
  function moveRelative(r, c) {
    this.move(this.r + r, this.c + c);
  }
  function moveUp() { this.moveRelative(-1, 0); }
  function moveDown() { this.moveRelative(1, 0); }
  function moveLeft() { this.moveRelative(0, -1); }
  function moveRight() { this.moveRelative(0, 1); }

  return Selection;
})();

// Update
function update() {
  
}

// Render
function render() {
  
}
